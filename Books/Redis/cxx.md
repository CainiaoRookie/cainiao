## 第一部分--数据结构与对象
### 2.简单动态字符串
1.redis使用SDS作为默认字符串表示。   
**SDS的结构**:   
len(记录buf数组中已使用字节的数量==SDS所保存的字符串长度)+free(记录buf数组中未使用字节的数量)+buf[]（字节数组,用于保存字符串)   
**SDS用途**:   
1.常数复杂度获取字符串长度 -- 记录自身长度,复杂度为O(1)   
2.杜绝缓存溢出 -- 当需要对SDS字符串进行修改时,API会自动将SDS的空间扩展至执行修改所需的大小,然后执行实际修改的操作   
3.减少修改字符串时带来的内存重分配次数 -- 通过未使用空间,SDS实现了空间预分配和惰性空间释放两种或优化策略。   
> 1.空间预分配:用于优化SDS的字符串增长操作,如果修改之后,SDS的长度将小于1MB,那么程序分配和len属性同样大小的未使用空间,如果大于1MB,就分配1MB的未使用空间。在扩展空间之前，SDS会先检查未使用空间是否足够,如果足够,则无需内存重分配  
> 2.惰性空间释放:用于优化SDS字符串缩短操作,当需要缩短SDS保存的字符串时,使用free属性将这些字节的数量记录起来,等待将来使用   
> 3.可以保存文本或者二进制文件
### 3.链表
链表被广泛用于实现Redis的各种功能,比如列表键,发布与订阅,慢查询,监视器等   
redis的链表实现是双端链表,链表表头节点的前置节点和表尾节点的后置节点都指向NULL,所以redis的链表实现是无环链表
### 4.字典
是一种用于保存键值对的抽象数据结构,使用哈希表作为底层实现,一个哈希表里面可以有多个哈希节点,而每个哈希表节点就保存了字典中的一个键值对。
哈希表的结构：
table(哈希表数组)+size(哈希表大小)+sizemask(哈希表大小掩码,用于计算索引值,总是等于size-1)+used(哈希表已有节点数量)
普通状态下的字典结构:
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181208163446784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4eDIwMTc=,size_16,color_FFFFFF,t_70))
ht属性是一个包含两个项的数组,数组中每个项都是一个dictht哈希表,一般情况下,字典只使用ht[0]哈希表,ht[1]哈希表只会对ht[0]哈希表进行rehash时使用   
**哈希算法:**当将一个新的键值对添加到字典里面时,需要先根据键值对的键计算出哈希值和索引值,然后再根据索引值,将包含新键值对的哈希表节点放到哈希表数组的指定索引上去   
**解决键冲突:**使用链地址法来解决哈希冲突,将新节点添加到链表表头   
**rehash:**扩展和收缩哈希表的工作可以通过执行rehash(重新散列)操作来完成,具体步骤:   
	1. 为字典的ht[1]哈希表分配空间,这个哈希表的控件大小取决于要执行的操作,以及ht[0]当前包含的键值对数量(ht[0].used属性的值),扩展则ht[1]=ht[0].used*2,收缩则ht[0].used*2^n   
	2. 将保存在ht[0]中的所有键值对rehash到ht[1]上,rehash指的是重新计算键的哈希值和索引值   
	3. ht[0]迁移到ht[1]后,释放ht[0],将ht[1]设置为ht[0],并在ht[1]中创建一个空白哈希表   
**扩展和收缩的条件:**
收缩:哈希表负载因子小于0.1,进行收缩
扩展:没有执行BGSAVE或者BGREWRITEAOF时,负载因子大于等于一,正在执行BGSAVE或者BGREWRITEAOF时,负载因子>=5
负载因子 = ht[0].used/ht[0].size
**渐进式rehash:**rehash的动作是分多次,渐进式完成的   
在rehash过程中,在字典中会维持一个索引技术器变量rehashidx,把他设置为0,表示rehash开始,每次rehas一次,就加一,完成后,设置为-1   
在渐进式rehash过程中,字典会同时使用ht[0]和ht[1]两个哈希表,字典的删除,查找,更新等操作中,
如果要查找的话,会现在ht[0]中查找,如果没有找到,继续在ht[1]中查找.添加操作均会在ht[1]中
###5.跳跃表
一种有序数据结构,他通过在每个节点中维持多个指向其他节点的指针,从而达到快速访问节点的目的。redis使用跳跃表作为有序集合键的底层实现。
**在redis中的用途**:1.实现有序集合键 2.在集群节点中用作内部数据结构
**结构**:   
zskiplist(保存跳跃表信息) -- header(指向跳跃表的表头节点)+tail(指向跳跃表的表尾节点)+level(记录跳跃表内,层数最大的节点的层数)+length(记录跳跃表的长度)   
zsliplistNode(表示跳跃表节点) -- 层(每层都有一个前进指针和跨度,层高都是1到32的随机数)+后退指针(节点中BW字样标记节点的后退指针,指向位于当前节点的前一个节点,每次只能后退至前一个节点)+分值(double类型的浮点数,跳跃表中的所有节点都按照分值从小到大排序)+成员对象(唯一)   
结构如下:
![在这里插入图片描述](https://img-blog.csdnimg.cn/2018120816350073.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4eDIwMTc=,size_16,color_FFFFFF,t_70)
### 6.整数集合(intset)
当一个集合只包含整数值元素,并且集合元素不多时,就会使用整数集合作为集合键的底层实现   
**结构**:encoding(编码方式)+length(集合包含元素数量)+contents[] (保存元素数组,从小到大有序排序,并且无重复)   
**升级**:添加新元素到整数集合,如果新元素的类型比整数集合现有所有元素类型都长,就需要升级   
> 1.根据新元素类型,扩展整数集合底层数组的空间大小,并为新元素分配空间   
> 2.将底层数组现有的所有元素都转换成新元素相同的类型   
> 3.将新元素添加到底层数组中去,如果新元素小于所有现有元素,则放置最开始(0),都大,放在末尾   

升级的好处:操作灵活性和节约内存
### 7.压缩列表
压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，就是用压缩列表来做列表键的底层实现。   
**结构**：是Redis为了节约内存而开发的,是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。   
zlbytes(记录整个压缩列表占用的内存字节数)+zltail(记录表尾节点到表头有多少字节)+zllen(压缩列表包含的节点数量)+entryX(压缩列表包含的各个节点)+zlend(标记压缩列表末端)   
每个压缩节点组成:previous_entry_length(记录压缩列表钱一个节点长度)+encoding(content属性所保存数据的类型以及长度)+content(保存节点的值)
**连锁更新**
### 8.对象
**字符串对象:**字符串对象的编码可以为int、raw或者embstr
1. 如果字符串对象保存的是一个字符串值，字符串大于32字节，则编码方式为raw,小于等于32,则编码方法为embstr(专门用于保存短字符串的一种优化编码方式)
2. 对于int编码的字符串,如果使该字符串不再是整数值而是一个字符串值,那么编码从int变为raw
3. 对embstr编码的字符串对象执行修改命令操作时,会将对象的编码从embstr转化为raw
**列表对象:**编码是ziplist或者linkedlist   
当列表对象同时满足以下两个条件,则使用ziplist:
1. 列表对象保存的所有字符串元素的长度都小于64字节
2. 列表对象保存的元素数量小于512
否则,都使用linkedlist   
**哈希对象:**哈希对象的编码可以是ziplist或者hashtable   
当列表对象同时满足以下两个条件,使用ziplist
1. 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节
2. 哈希对象保存的键值对数量小于512
否则,都使用hashtable   
**集合对象:**集合对象的编码可以是intset或者hashtable   
当列表对象同时满足以下两个条件,使用intset
1. 集合对象保存的对象都是整数
2. 集合对象保存的元素数量小于512
否则,都使用hashtable   
**有序集合对象:**有序集合的编码是ziplist或者skiplist   
当列表对象同时满足以下两个条件,则使用ziplist:
1. 有序集合保存的元素数量小于128个
2. 有序集合保存的所有元素成员的长度小于64字节
否则,都使用skiplist  
**内存回收:** 通过跟踪对象的引用计数信息,在适当的时候自动释放对象并进行内存回收   
1. 当创建一个新对象的时候,引用计数的值会被初始化为1
2. 当对象被一个新程序使用时,他的引用计数值会+1
3. 当对象不再被一个程序使用时,他的引用计数会-1
4. 当对象的引用计数值为0时,对象所占用的内存会被释放    
**对象共享:**会共享值为0到9999的字符串对象
## 第二部分-- 单机数据库的实现
### 9.数据库
1. redis服务器默认会创建16个数据库      
2. 切换数据库:每个redis客户端都有自己的目标数据库,默认为0号数据库,可以通过Select命令切换数据库   
3. 数据库主要由dict(保存键值对)+expirs(保存键的过期时间)两个字典构成     
4. redis使用惰性删除和定期删除两种策略来删除过期键。惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每个一段时间主动查找并删除过期键   
5. 执行SAVE命令或者BGSAVE命令所产生的新的RDB文件不会包含已经过期的键   
6. 执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经到期的键   
7. 当一个过期键被删除后,服务器会追加一条DEL命令到现有AOF文件末尾,显式的删除过期键   
8. 当主服务器删除一个过期键之后,他会向所有从服务器发送一条DEL命令,显式的删除过期键   
9. 从服务器即时发现过期键也不会自作主张的删除,而是等待主节点发来DEL命令      
### 10.RDB持久化   
1. RDB文件是一个经过压缩的二进制文件,通过该文件可以还原生成RDB文件时的数据库状态
2. **RDB文件的创建:**SAVE和BGSAVE都可以用于生成RDB文件,SAVE命令会阻塞服务器进程,直至RDB文件创建完毕为止,服务器不能处理任何命令请求,BGSAVE命令会派生出一个子进程,然后由子进程负责创建RDB文件,服务器进程继续处理命令请求。BIGSAVE执行期间,服务器会拒绝SAVE和BIGSAVE命令,BGREWRITEAOF会延迟到BIGSAVE命令执行完毕之后执行。BGREWRITEAOF命令正在执行，拒绝BIGSAVE
3. **RDB文件载入:**在服务器启动时自动执行。由于AOF文件的更新频率比RDB文件的更新频率高,所以,如果服务器开启了AOF持久化功能,那么服务器会优先使用AOF.服务器在载入RDB文件期间,会一直处于阻塞状态,直至载入完毕
4. **RDB文件结构:**   
REDIS(检查是否是RDb文件)+db_version(4个字节,记录了RDB文件的版本号)+databases(保存任意多个非空数据库)+EOF(1个字节,表示正文内容结束)+check_sum(8个字节,保存校验和)
RDB中数据库结构:SELECTDB+db_number(数据库号码)+key_value_pairs(爆粗拿了数据库中所有键值对数据)
键值对的结构:
不带过期时间的键值对:TYPE(对象类型或者底层编码)+key(键值对的键对象)+value(键值对的值对象)
带有过期时间的键值对:EXPIRETIME_MS+ms(时间戳)+TYPE(对象类型或者底层编码)+key(键值对的键对象)+value(键值对的值对象)
### 11.AOF持久化
通过保存数据库中的键值对来记录数据库状态不同,AOF持久化通过保存Redis服务器所执行的写命令来记录数据库状态  
AOF文件中的所有命令都以redis命令请求协议的格式保存,命令请求会先保存到AOF缓冲区里面,再定期写入并同步到AOF文件
**AOF持久化实现:**分为三步-- 命令追加+文件写入+文件同步
**AOF文件的载入与数据还原:**AOF文件里面包含了重建数据库状态所需要的所有写命令,所有服务器只要读入并重新执行一遍AOF文件里面保存的写命令,就可以还原服务器关闭之前的数据库状态
**AOF重写:**解决AOF文件体积膨胀的问题 ,通过读取数据库中的键值对来实现  
AOF重写程序会放到子进程中去执行,在AOF重写期间,服务器进程可以继续执行命令请求,但会造成数据不一致为,redis服务器会维护一个AOF重写缓冲区,该缓冲区会在子进程创建新的AOF文件期间,记录服务器执行的所有写命令,当子进程完成创建新AOF文件的工作之后,服务器会重写缓冲区中的所有内容追加到新的AOF文件末尾,最后,用新的AOF替换旧的AOF文件
即在进程执行AOF重写期间,执行以下三个工作:   
1.执行客户端发来的命令   
2.将执行后的写命令追加到AOF缓冲区   
3.将执行后的写命令追加到AOF重写缓冲区
### 12.事件
1.文件事件:服务器对套接字操作的抽象,服务器与客户端的通信会产生相应的文件事件,服务器通过监听并处理这些时间来完成一系列网络通信操作   
文件事件处理器使用I/O多路复用程序来同时监听多个套接字   
文件事件处理器的构成:套接字+I/O多路复用程序+文件事件分派器+事件处理器,如果多个文件事件并发出现,会将产生事件的套接字放到队列中,通过这个队列以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字,向文件事件分派器根据不同的时间类型,调用相应的时间处理器
事件的类型：   
	1. 当套接字变的可读(客户端对套接字执行write或者close),套接字产生AE_READABLE事件   
	2. 当套接字变的可写(客户端对套接字执行read),套接字产生AE_WRITABLE事件   
	3. 如果一个套接字既可读又可写,那么服务器先读套接字,后写套接字   
文件事件的处理器:
连接应答处理器:对连接服务器的各个客户端进行应答,与AE_READABLE事件关联
命令请求处理器:为了接收客户端传来的命令请求,会将客户端套接字的AE_READABLE事件和命令请求处理器关联起来
命令回复处理器:为了向客户端返回命令的执行结果。当服务器有命令回复需要传给客户端的时候，服务器会将客户端套接字的AE_WRITABLE事件和命令回复处理器关联起来
2.时间事件:服务器对定时操作的抽象   
定时事件:让一段程序在指定的时间之后执行一次   
周期性事件:让一段程序每隔指定时间执行一次   
时间事件的属性:id(服务器为时间事件创建的全局唯一ID)+when(时间戳-毫秒)+timeProc(时间事件处理器,一个函数)   
实现:服务器将所有时间事件都放在一个无序链表(指的是不按when进行排序)中,每当时间事件执行器运行时,就遍历整个链表,查找所有已达到的时间事件,并调用相应的事件处理器   
serverCron函数:需要定期的对自身的资源和状态进行检查和调整。服务器在一般情况下，只执行serverCron函数一个时间时间，并且这个事件是周期性事件   
文件事件和时间事件是合作关系，服务器会轮流处理这两种时间，不会发生抢占，且时间事件的实际处理时间通常比设定的到达时间晚一点   
### 13.客户端
**客户端属性：**   
套接字描述符 -- 客户端状态fd属性记录了客户端正在使用的套接字描述符。df=-1为伪客户端(处理命令的请求来源与AOF文件或者Lua脚本),df>-1为普通客户端(使用套接字与服务器进行通信)   
名字 -- 默认情况下连接到服务器的客户端是没有名字的   
标志 -- flags记录了客户端的角色以及客户端目前所处的状态   
输入缓冲区 -- 保存客户端发送的命令请求。输入缓冲区的大小会动态的缩小或者扩大，但不能超过1GB   
命令与命令参数 -- 在服务器将客户端发送的命令请求保存到客户端状态querybuf属性后,服务器将对命令请求的内容进行分析,并将得出的命令参数以及命令参数个数分别保存到客户端状态的argv(是一个数组,每个项是一个字符串,argv[0]是要执行的命令,之后的其他项是传给命令的参数)和argc属性中   
命令的实现函数 -- 根据argv[0]的值,在命令表中查找命令所对应的命令实现函数   
输出缓冲区 -- 执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个是固定大小(保存长度,最大16KB,数组)，一个是可变的(保存长度大的,链表来连接多个字符串)
身份验证 -- authenticated属性用来记录客户端是否通过了身份验证,=0表示未通过,=1表示通过。仅在服务器启用了身份验证时使用   
**客户端的创建与关闭**      
创建普通客户端：通过网络连接与服务器进行连接的普通客户端，在客户端使用connext函数连接到服务器时,服务器就会调用连接事件处理器,为客户端创建相应的客户端状态,并将这个新的客户端状态添加到服务器状态结构链表的末尾   
关闭普通客户端:客户端进程退出或者被杀死;客户端向服务器发送了带有不符合协议格式的命令请求;客户端成为了CLIENT KILL命令的目标;超过tomcat设置的timeout配置选项;客户端发送的命令请求的大小超过了输入缓冲区的限制大小(默认1GB);发送给客户端的命令回复的大小超过了输出缓冲区的限制大小
Luna脚本的伪客户端:伪客户端在服务器运行的整个生命周期会一直存在,只有服务器被关闭,客户端才会被关闭
AOF文件的伪客户端:服务器再载入AOF文件完成后,关闭伪客户端
### 14.服务器
**命令请求的执行过程:**   
发送命令请求:用户输入命令后,客户端会将命令请求转换成协议格式,然后通过来南街道服务器的套接字发送   
读取命令请求:分析命令请求并保存到argv和argc中,调用命令执行器   
命令执行器:   
> 1.查找命令实现 -- 根据客户端状态arg[0]参数,在命令表(字典,字典的键是命令的名称,字典的值是redisCommand结构)中查找参数所指定的命令,并将所找到的命令保存到客户端状态的cmd属性里面   
> 2.执行预备操作   
> 3.调用命令的实现函数 -- 执行指定的操作,并产生相应的命令回复,回复会被保存在客户端状态的输出缓冲区里面
> 4.执行后续工作   
将命令回复发送到客户端   
客户端接收并打印命令回复 -- 将回复格式装换成可读格式 
**ServerCron函数**   
默认每隔100毫秒执行一次,负责管理服务器的资源,并保持服务器自身的良好运转,他的工作主要包括更新服务器状态信息,处理服务器接收SIGTERM信号,管理客户端资源和数据库状态,检查并执行持久化操作
**初始化服务器**
1.初始化服务器状态结构:用initServerConfig函数初始化完server变量    
2.载入配置选项:载入用户给定的配置文件和配置参数   
3.初始化服务器数据结构:   
4.还原数据库状态:服务器需要载入RDB文件或者AOF文件,根据文件记录的内容还原服务器数据库的状态   
5.执行数据循环   
## 第二部分-- 多机数据库的实现			
### 15.复制
用户通过执行SLAVEOF命令或者设置slaveof选项,让一个服务器去复制另一个服务器,则被复制的服务器为主服务器,另一台为从服务器   
**旧版复制功能实现**:分为同步和命令传播两个操作   
同步 -- 用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态   
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181229141305286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4eDIwMTc=,size_16,color_FFFFFF,t_70)   
命令传播 -- 用于在主服务器的数据库状态被修改,导致主从服务器的数据库状态不一致时,让主从服务器的数据库重新回到一致状态   
旧版缺陷 -- 断线后重复制耗费资源时间,sync命令耗费资源(生成RDB文件,发送RDB文件以及从服务器载入RDB文件(阻塞))   
**新版复制功能实现**:用PSYNC代替SYNC,有完整重同步和部分重同步两种模式   
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181229141315296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4eDIwMTc=,size_16,color_FFFFFF,t_70)   
部分重同步功能由三部分构成:
> 1.主服务器的复制偏移量和主服务器的复制偏移量:如果主从服务器偏移量不一致,则不处于一致状态。  
> 2.复制积压缓冲区:是主服务器维护的一个固定长度的先进先出的队列,默认大小为1MB。当主服务器进行命令传播时，不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面,复制积压缓冲区会为队列中每个字节记录相应的复制偏移量
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181229141325667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4eDIwMTc=,size_16,color_FFFFFF,t_70)   
如果offset偏移量之后的数据仍存在在复制积压缓冲区中,则执行部分重同步,否则执行完整重同步
> 3.服务器运行ID:每个redis服务器都有自己的运行ID,启动时自动生成,由40个随机16进制字符组成。当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传给从服务器,从服务器保存该ID,断线重连后,发送该ID,如果一致,则可尝试部分重同步

**执行过程**   
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181229141334251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4eDIwMTc=,size_16,color_FFFFFF,t_70)   
runid表示上一次复制的主服务器的运行ID,offset表示从服务器当前的复制偏移量   
如果返回-ERR,表示主服务器版本低于redis2.8   
**复制的实现**   
1.设置主服务器的地址和端口   
2.建立套接字连接   
3.发送PING命令
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181229141345267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4eDIwMTc=,size_16,color_FFFFFF,t_70)   
4.身份验证:从服务器在收到主服务器返回的PONG回复之后,接着决定是否进行身份验证(如果设置了masterauth则进行身份验证)   
5.发送端口信息:在身份验证之后,从服务器向主服务器发送从服务器的监听端口号   
6.同步:从服务器向主服务器发送PSYNC命令,执行同步操作。在同步操作之后，主服务器同时也会成为从服务器的客户端   
7.命令传播：   
**心跳检测**在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令，其作用有
> 1.检测主从服务器的网络连接状态
> 2.辅助实现min-slaves配置选项 -- 可以防止主服务器在不安全的情况下执行写命令
	min-slaves-to write 3
	min-slaves-max-lag 10
则从服务器数量少于3个,或者三个从服务器的延迟都大于等于10,主服务器都将拒绝执行写命令
> 3.检测命令丢失:补发
###16.Sentinel
Sentinel(哨兵)是redis的高可用性解决方案,由一个或多个Sentinel组成的Sentinel系统可以监视任意多个主服务器,以及这些主服务器属下的所有从服务器,并在被监视的主服务器进入下线状态时,自动将下线主服务器下的某个从服务器升级为主服务器   
**启动并初始化Sentinel:**   
> 1.初始化服务器   
> 2.使用Sentinel专用代码:将一部分普通Redis服务器使用的代码替换成Sentinel专用代码   
> 3.初始化Sentinel状态   
> 4.初始化Sentinel状态的masters属性:masters字典记录了所有被Sentinel监视的主服务器的相关信息   
> 5.创建连向主服务器的网络连接:Sentinel将成为主服务器的客户端,可以向主服务器发送命令,并从命令回复中获取相关信息(创建两个异步网络连接 -- 命令连接[向主服务器发送命令,接收回复]和订阅连接[订阅主服务器])   

**获取主服务器信息:**   
默认以十秒一次的频率,通过命令连接向被监视的主服务器发送INFO命令   
**获取从服务器信息:**   
当Sentinel发现主服务器有新的从服务器出现时,Sentinel会为这个新的从服务器创建相应的实例结构外,还会创建连接到从服务器的命令连接和订阅连接   
**向主服务器和从服务器发送信息:**   
默认情况下,Sentinel会以每两秒一次的频率,通过命令连接向所有被监视的主服务器和从服务器发送信息   
**接收来自主服务器和从服务器的频道信息:**   
更新Sentinels字典   
创建连向其他Sentinel的命令连接    
**检测主观下线状态:**  
默认情况下,Sentinel会以每秒一次的频率向所有与他创建了命令连接的实例发送PING命令回复来判断实例是否在线（有效回复：实例返回+PONG,-LOADING,-MASTERDOWN的其中一个）。down-after-milliseconds只定了Sentinel实例进入主观下线所需的时间长度   
**检测客观下线状态:**   
客观下线的条件:当认为主服务器已经进入下线状态的Sentinel数量超过了Sentinel配置中设置的quorum参数的值,那么该Sentinel就会任务该主服务器一斤进入客观下线状态  
**选举领头Sentinel:**  
当一个主服务器被判断为客观下线时,监视这个下线主服务器的各个Sentinel会选举出一个选举领头Sentinel,并由领头Sentinel对下线主服务器执行故障转移操作   
**故障转移**    
选举出领头Sentinel后,领头Sentinel对已下线主服务器进行故障转移,步骤:   
> 1.在已下线主服务器属下的所有从服务器里,挑选一个从服务器,将其转换为主服务器   
> 2.让已下线主服务器属下的所有从服务器改为复制新的主服务器   
> 3.让已下线主服务器设置为新服务器的从服务器   
###17.集群   
Resdis是redis提供的分布式数据库方案,集群通过分片来进行数据共享,并提供复制和故障转移的功能   
**节点:**一个redis集群由多个节点组成,在刚开始的时候,每个节点都是相互独立的。要组建一个真正可工作的集群，必须将每个独立节点连接起来，构成一个包含多个节点的集群
CLUSTER MEET : 握手过程   
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/2018122914135973.png)  
**槽指派:**   
Redis集群通过分片的方式来保存数据库中的键值对。集群的整个数据库被分为16384个槽，数据库中的每个键都属于这16384个槽的其中一个，集群中每个节点可以处理0个或最多16384个槽。   
当数据库中的16384个槽都有节点在处理时，集群处于上线状态，如果数据库中有任何一个槽没有得到处理，处于下线状态   
每个节点都会记录节点的槽指派信息，clusterNode(节点)中有个slots[16384/8]的二进制位数据,如果值为1,表示负责处理槽;为0则不负责   
传播节点的槽指派信息:会将自己负责哪些槽的信息发送给集群中的其他节点   
记录集群所有槽的指派信息:clusterState结构中slot数组记录了集群中所有16384个槽指派信息   
**在集群中执行命令:**   
当客户端向节点发送与数据库键有关命令时,接收命令的节点会计算出命令要处理的数据库键属于哪个槽,并检查这个槽是否指派给了自己:   
如果指派给了自己,则执行命令   
如果没有指派给自己,则返回一个MOVED错误,指引客户端转向正确的节点执行命令   
节点只能使用0号数据库,除了将键值对保存在数据库里面之外,还会用跳跃表来保存键值对之间的关系   
**重新分片:**   
可以将任意数量已经指派给某个节点的槽改为指派给另一个节点,并且相关槽所述的键值对也会从源节点被移动到目标节点   
**ASK错误:**  
在重新分片期间,源节点向目标节点迁移一个槽的过程中,如果节点收到一个关于键key的命令请求,节点没有在自己的数据库中找到键key,则节点会检查自己的clusterState.migrating_slots_to[i]中查看键key所属的槽i是否在进行迁移,如果正在进行迁移,那么节点会向客户端发送一个ASK错误,引导客户端到正在导入槽i的节点去查找键Key.会先向目标节点发送ASKING命令(如果不发送,则会直接拒绝执行),在重新发送原本想要执行的命令   
ASK错误与MOVED错误区别:   
1.MOVED错误代表槽的负责全已经从一个节点转移到了另一个节点
2.ASK错误只是两个节点在迁移槽的过程中的一个临时措施   
**复制与故障转移:**  
Redis集群中的节点分为主节点和从节点,主节点用于处理槽,从节点用于复制某个主节点,当主节点下线时,则会代替主节点继续处理命令   
**消息**   
集群中的各个节点通过发送和接收消息来进行通信,主要有五种:
MEET:请求接收者加到如发送者当前所处的集群(CLUSTER MEET)   
PING:每隔一秒   
PONG:确认消息已到达(MEET,PING)
FAIL:当一个主节点A判断另一个主节点B已经进入FAIL状态时,会广播一条节点B的FAIL消息,其他节点将将标记B为下线状态
PUBLISH:当节点接收到一个PUBLISH,节点会执行这个命令,并向集群广播一条PUBLISH消息
### 18.发布与订阅
发布与订阅功能由PUBLISH,SUBSCRIBE,PSUBSCRIBE等命令组成   
服务器状态在pubsub_channels字典保存了所有频道的订阅关系,SUBSCRIBE负责将客户端和被订阅的频道关联到这个字典里面,UNSUBSCRIBE负责移除客户端和被退订频道之间的关联   
pubsub_patterns链表保存了所有模式的订阅关系,PSUBSCRIBE负责将客户端和被订阅的频道关联到这个链表里,PUNSCRIBE负责移除客户端和被退订频道在链表里的记录   
PUBLISH通过访问pubsub_channels字典来向频道所有的订阅者发送消息,通过访问pubsub_patterns链表来向所有匹配频道的模式的订阅者发送消息   
### 19.事务
Redis通过EXEC,MULTI,WATCH等命令来实现事务功能。事务提供了一种将多个命令请求打包，然后一次性，顺序执行多个命令的机制   
**事务的实现：**   
事务开始: MULTI标志事务的开始     
命令入队: 如果发送的命令为EXEC,DISCARD,WATCH,MULTI四个命令中以外的命令,则会放入一个事务队列中,然后向客户端返回QUEUED回复(事务队列是一个先进先出方式)    
事务执行:当一个处于事务状态的客户端向服务器发送EXEC命令时,这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端        
**WATCH命令的实现**  
WATCH命令是一个乐观锁,可以在EXEC命令执行之前,监视任意数量的数据库键,并在EXEC命令执行时,检查被监视的键是否至少有一个已经被修改过了,如果修改过,则服务器拒绝执行事务,并向客户端返回执行失败的空回复   
当服务器接收到一个客户端发来的EXEC命令时,服务器会根据这个客户端是否打开了REDIS_DIRTY_CAS标识来决定是否执行事务(REDIS_DIRTY_CAS被打开,则表示被修改过,则服务器会拒绝执行客户端提交的事务,REDIS_DIRTY_CAS没有被打开,则没被修改过,事务安全)   
**事务的ACID性质**   
原子性:事务队列中的命令要么全部执行,要么一个都不执行。不支持事务回滚机制   
一致性:   
隔离性:redis事务使用串行的方式运行   
耐久性:当一个事务执行完毕时,执行这个事务所得的结果已经被保存到永久性存储介质中,即时服务器再事务执行完毕之后停机,其结果也不会丢失,只有当服务器在AOF持久化模式下,并且appendfsync选项的值为always时,事务具有耐久性
###20.Lua脚本   
Redis服务器专门使用一个伪客户端来执行Lua脚本中包含的Redis命令   
Redis使用脚本字典来保存所有被EVAL命令执行过,或者被SCRIPT LOAD命令载入过的Lua脚本,这些脚本可以用于实现SCRIPT EXISTS命令,以及实现脚本复制功能   
EVAL命令为客户端输入的脚本在Lua环境中定义一个函数,并通过调用这个函数来执行脚本   
EVALSHA命令通过直接调用Lua环境中已定义的函数来执行脚本   
SCRIPT FLUSH命令会情况服务器lua_scripts字典中保存的脚本,并重置Lua环境   
SCRIPT EXISTS命令接受一个或者多个SHAI校验和为参数,并通过检查lua_scripts字典来确认校验和对应的脚本是否存在   
SCRIPT LOAD命令接受一个Lua脚本作为参数,为该脚本在Lua环境中创建函数,并将脚本保存到lua_scripts字典中
### 21.排序   
1.默认情况下,SORT命令假设被排序键包含的都是数字值,并且以数字值的方式来进行排序   
2.如果SORT使用了ALPHA(sort key ALPHA)选项,那么SORT命令假设被排序键包含的都是字符串值,并且以字符串的方式进行排序
3.SORT命令的排序操作者由快速排序算法实现
4.SORT命令使用by(sort key by)选项时,命令使用其他键的值作为权重来排序操作,使用LIMIT(limit offset[跳过的已排序元素数量] count[要返回的元素数量]),命令只保留排序结果集中LIMIT选项指定的悬殊
5.SORT命令使用get选项时,命令会根据排序结果集中的元素以及get给定的模式,查找并返回其他键的值
6.SORT命令使用store选项时,命令会先将排序结果集保存在指定的键里面
7.当SORT命令同时使用多个选项时,命令限制性排序操作(ALPHA,ASC,DESC,BY),然后执行LIMIT,之后执行GET,再之后执行STORE,最后才将排序结果集返回给客户端 
### 22.二进制位数组   
Redis使用字符串对象来表示位数组,因为字符串对象使用的是SDS数据结构是二级制安全的,所以程序可以直接使用SDS结构来保存位数组   
使用逆序来保存位数组  
### 23.慢查询日志   
用于记录执行时间超过给定时长的命令请求,用户可以通过这个功能产生的日志来监视和优化查询速度,有两个配置与此相关:   
slowlog-log-slower-than -- 指定执行时间超过多少微秒的命令请求会被记录到日志上   
slowlog-max-len -- 选项指定服务器最多保存多少条慢查询日志(先进先出)   
redis服务器所有的慢查询日志保存在服务器状态的slowlog链表中,每个链表节点都包含一个slowlogEntry结构,每个slowlogEntry结构代表一个慢查询日志   
打印和删除慢日志可以通过遍历slowlog链表来完成,新的慢日志会被添加到链表表头
### 24.监视器   
1.客户端可以通过执行MONITOR命令,将客户端转换为监视器,接收并打印服务器处理的每个命令请求的相关信息   
2.当一个客户端由普通客户端变为监视器,该客户端的REDIS_MONITOR标识会被打开
3.服务器将所有监视器都记录在monitors链表中
4.每次处理命令请求,服务器都会遍历monitors链表,将相关信息发送给监视器   
