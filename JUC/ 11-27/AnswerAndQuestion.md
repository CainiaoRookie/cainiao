###  volatile,DCL
**1.volatile如何禁止重排序：**   
volatile禁止重排序的规则：   
1.第一个操作是volatile读，无论第二个操作是什么，都禁止重排序   
2.第二个操作是volatile写，无论第一个操作是什么，都禁止重排序   
3.第一个操作是volatile写，第二个是volatile读，禁止重排序     
volatile修饰的变量，**在编译时，会在指令序列中插入内存屏障来禁止重排序**。java内存模型采用保守策略插入内存屏障。  
1.在volatile写操作之前插入storestore屏障（禁止上面普通写和自己重排序）   
2.在volatile写操作之后插入storeload屏障（禁止下面volatile读和写）   
3.在volatile读操作之后插入loadload屏障（禁止下面普通读和自己重排序）   
4.在volatile读操作之后插入loadstore屏障（禁止下面普通写和自己重排序）      
**2.volatile如何实现内存可见性：**   
在Java内存模型中，所有变量都存储在主内存中，所有线程都可以访问，每个线程创建时，JVM都会为线程创建一个工作内存，线程对变量的操作是在工作内存中进行的。会先写到工作内存，再更新到主内存中 ，被volatile修饰的变量，会将更新的值直接刷新到主内存中。   
**3.DCL(double check lock)是什么原因造成单例失效：**   
在创建对象时，由于对象的创建不是 原子操作，他包括：
1.分配对象的内存空间 
2.初始化对象
3.将对象实例指向分配的内存空间
2和3可能会被重排序，导致在多线程环境下，导致单例失效
