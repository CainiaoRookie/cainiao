## AQS
#### 1.CHL队列是如何插入新的Node的?
①先将新的结点构造成Node对象，然后获取CHL尾节点。   
②如果尾结点存在，则将插入结点的前驱指向尾节点，在利用CAS将CHL的tail指向插入的结点，最后将尾节点的next指向指向插入结点。   
③如果尾结点不存在，进入自旋，自旋中获取CHL中tail这个Node，如果tail是空，则利用CAS构造一个空Node，并将这个Node赋值给CHL的tail和head。   
④（因为自旋，所以第二次进入时，tail和head指向的都是上面③中的Node）如果tail不为空，将插入结点的前驱指向CHL的tail这个Node，在利用CAS将设置CHL的tail指向插入的node，并将之前旧的tail的Node的next指向插入的Node。   
#### 2.尝试获取锁失败，构建成Node添加到CHL队列后，调用acquireQueued操作主要是干嘛的? 
acquireQueued主要是想获取该线程构造的node前驱，如果前驱是head，则再次尝试获取锁，如果获取成功，则从CHL中删除该node，如不成功或前驱不是head，则清除CHL中超时或被中断的node，并设置node的状态为signal，等待状态，最后使用LockSupport.park阻塞线程。 
#### 3.说说LockSupport.park、LockSupport.unpark方法
LockSupport调用的是底层unsafe的native方法，park是阻塞，每个使用LockSupport的线程都会与一个许可关联，如果该许可可用，并且可在线程中使用，则调用park()将会立即返回，否则可能阻塞，当阻塞了，调用unpark可以使许可可用，就变成了非阻塞，但是park不可重入，所以park只能调用一次。 
#### 4.获取独占锁失败后线程如何工作
当线程获取同步锁失败后，会将当前线程构造成Node对象，将节点加入到同步队列尾部，最后调用acquireQueued方法，使该节点以死循环的方式获取同步状态，如果获取不到，则阻塞节点中的线程。    
#### 5.队列中线程如何释放同步锁
释放独占锁的过程:      
1.调用子类tryRelease方法释放资源,如果释放成功,则去唤醒等待锁资源的线程；   
2.释放资源的过程:将当前节点的状态设置为0,寻找到下一个非取消状态的节点,如果该节点不为null,调用LockSupport.unpark唤醒该线程。   
释放共享锁的过程:   
调用子类tryReleaseShared尝试释放共享锁,如果释放成功, 则唤醒队列中等待的节点,如果有的话(无论读锁还是写锁)。
#### 6.独占锁和共享锁的区别
当锁头结点被获取后,独占功能是只有头结点获取锁,其余节点的线程继续沉睡,等待锁被释放后,才会唤醒下一个节点的线程；
共享功能是只要头结点获取锁成功,就会唤醒自身节点对应的线程的同时,继续唤醒AQS队列中的下一个节点的线程,每个节点在唤醒自身的同时会唤醒下一个节点对应的线程。
