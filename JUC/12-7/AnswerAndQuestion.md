## ArrayList、Condition
#### 1.默认长度多少、扩容是扩容多少大小，扩容数据怎么处理的、初始化长度多少，modCount作用是什么?
默认长度10，扩容len+len/2取整，数据使用Array.copy方式，而不是for循环，初始化长度是0，modCount作用是记录每次结构中数据、长度等变化次数，用于在迭代器循环时，采用类似CAS防止在迭代时出现被结构中数据被删除等异常的情况。
#### 2.Condition的等待队列和AQS中CHL队列在形式上有什么区别
Condition的等待队列是单向的，包含prev的，而CHL是双向队列，同时，Condition是不带头结点的
#### 3.简述condition.await过程
condition.await后，会将该线程构成一个Node，此Node复用AQS中内部类Node，然后会将这个Node加到等待队列的对尾，并且释放锁，让其他线程可以获取锁，然后进入自旋判断CHL队列中有没有这个Node(这个是通过signal将等待队列的node移到CHL队列中)，当循环到CHL中有此Node后，就调用acquireQueued进行获取锁，如何获取和之前AQS内容里一样，获取到之后，删除同步队列中的Node
#### 4.ArrayList是如何扩容的
用add 方法的时候会判断是否需要进行数组扩容,查看当前数组长度是否能够存放size+1个元素,
如果不能,则进行扩容,每次扩容的大小为原来大小的 1.5倍,扩容的过程其实是一个将原来元素拷贝到一个扩容后数组大小的长度新数组中
#### 5.condition调用await后是将当前线程添加到等待队列的,如何释放锁
首先,将当前节点包装成Node，如果等待队列的firstWaiter为null的话（等待队列为空队列），则将firstWaiter指向当前的Node,否则，
更新lastWaiter(尾节点)即可。就是通过尾插入的方式将当前线程封装的Node插入到等待队列中即可。
接着，调用AQS的模板方法release方法释放AQS的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程，如果释放成功则正常返回，若失败的话就抛出异常。
#### 6.线程是如何从await方法退出的
退出await方法必须是已经获得了condition引用（关联）的lock。
有两种情况：
1.其他线程调用 signal 进行转移
2.当前线程被中断而进行Node的转移
之后通过自旋线程不断尝试获取同步状态，直至成功（线程获取到lock）
